---
description: 当用户提供算法题目时，按此规则创建完整的题目文件结构、分析文档，并维护分布式索引
alwaysApply: true
---

# 创建算法题目 — 完整工作流

当用户提供一道算法题目时（链接、截图、文字描述均可，来源不限），严格按以下步骤执行。

## 第一步：解析题目信息

从用户输入中提取：

- **题号**（4 位补零，如 0001）
- **中英文标题**、**英文 slug**（用于目录名）
- **难度**: Easy / Medium / Hard
- **标签**: 对应 `topics/README.md` 中的知识点分类
- **来源链接**（可选）

## 第二步：创建目录和文件

1. 计算分桶: `floor(题号/100)*100` → 起始，`+99` → 结束
2. 创建目录: `solutions/{分桶}/{题号4位}-{slug}/`
3. 生成以下 3 个文件：

### solution.go

~~~go
// {题号}. {中文标题}
// 难度: {Easy/Medium/Hard}
// 标签: {标签列表}
package p{题号4位}

// {函数名} ...
//
// 思路:
//
// 时间复杂度: O(?)
// 空间复杂度: O(?)
func {与原题一致的函数签名} {
    // TODO: 请在此实现你的解法
}
~~~

- 函数签名与原题一致，仅留骨架不写实现
- 用到 ListNode/TreeNode 时，导入 `algorithm-analysis/pkg/datastructs` 并用类型别名引入

### solution_test.go

~~~go
package p{题号4位}

import "testing"

func Test{函数名}(t *testing.T) {
    tests := []struct {
        name string
        // 输入输出字段
    }{
        {name: "示例1", ...},
        {name: "示例2", ...},
        {name: "边界-空输入", ...},
        {name: "边界-极值", ...},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 调用函数并断言
        })
    }
}
~~~

- table-driven 风格，包含题目给出的所有示例 + 至少 2 个边界用例
- 复杂类型用 `reflect.DeepEqual` 比较

### README.md

按 `problem-readme` 规则生成完整的教学分析文档。
这是学习者理解题目的核心材料，必须严格遵循其认知路径结构。

## 第三步：维护索引

创建题目后，必须同步更新以下索引文件：

### 3a. 分桶索引 `solutions/{分桶}/README.md`

若文件不存在则创建，格式：

~~~markdown
# {分桶范围}

| 题号 | 标题 | 难度 | 标签 | 状态 |
|------|------|------|------|------|
| {题号} | [{标题}]({题号}-{slug}/README.md) | {难度} | {标签} | ⬜ |
~~~

若已存在，在表格中追加一行。

### 3b. 总分桶入口 `solutions/README.md`

若当前分桶是新桶，在表格中追加一行：

~~~markdown
| {范围} | 1 | [{范围}]({范围}/README.md) |
~~~

若分桶已存在，更新对应行的题数。

### 3c. 知识点索引 `topics/{topic}.md`

为题目的每个标签，找到对应的 topic 文件。若文件不存在则创建，格式：

~~~markdown
# {知识点名称}

| 题号 | 标题 | 难度 | 状态 |
|------|------|------|------|
| {题号} | [{标题}](../solutions/{分桶}/{题号}-{slug}/README.md) | {难度} | ⬜ |
~~~

若已存在，在表格中追加一行。

### 3d. 知识点总览 `topics/README.md`

更新对应分类的题数计数。

## 第四步：完成提示

文件创建完成后，简要告知用户：
1. 已创建的文件清单
2. 建议先阅读 README.md 中的「真实场景」和「思维推导」，建立直觉后再动手
3. 然后在 solution.go 中编写解法，完成后告知 AI 进行验证
